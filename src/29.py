# coding=utf-8

'''
Consider all integer combinations of ab for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:

22=4, 23=8, 24=16, 25=32
32=9, 33=27, 34=81, 35=243
42=16, 43=64, 44=256, 45=1024
52=25, 53=125, 54=625, 55=3125

If they are then placed in numerical order, with any repeats removed, 
we get the following sequence of 15 distinct terms:

4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125

How many distinct terms are in the sequence generated by ab 
for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?
'''

import time, mtools

tab ={
32: (2, 5), 64: (2, 6), 4: (2, 2), 81: (3, 4), 8: (2, 3), 9: (3, 2), 16: (2, 4)
, 49: (7, 2), 25: (5, 2), 27: (3, 3), 36: (6, 2), 100: (10, 2)}

primes = [x for x in range(2, 100) if mtools.is_prime(x)]

def init():
   global tab, primes
   for i in range(2, 101):
      v = prime_prod(i)
      if v:
         tab[i] = v
   print tab

def prime_prod(n):
   p,c = mtools.prime_factors(n)
   if len(p) == 1 and c[0] > 1:
      return (p[0], c[0])
   return None

def check_v(l):
   t = {}
   for (a, b) in l:
      k = a**b
      if t.has_key(k):
         print t[k], (a, b)
         assert False
      t[k] = (a, b)

def unique(l):
   return list(set(l))

def transform(l):
   global tab
   l = unique(l)
   for i in range(0, len(l)):
      (a, b) = l[i]
      if tab.has_key(a):
         (v1, v2) = tab[a]
         l[i] = (v1, v2*b)
   r = unique(l)
   check_v(r)
   return r

def sequence_items_num(n):
   l = [(a, b) for a in range(2, n+1) for b in range(2, n+1)]
   l = transform(l)
   return len(l)

def test():
   assert sequence_items_num(5) == len([4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125])

def solve():
   return sequence_items_num(100)

if __name__ == "__main__":
   #init()
   test()
   t = time.time()
   print solve()
   print "(%s)" % (time.time() - t)
